<!--
 * @Author: Azhou
 * @Date: 2021-09-28 20:37:01
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-04 22:53:56
-->
# Go语言结构体

+ 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合
+ 结构把有内在联系的不同类型的数据统一成一个整体，使它们相互关联
+ 结构是变量的集合，从外部看是一个实体
+ 结构支持嵌套
+ 结构的字段类型不限
+ 结构的存储空间连续，按声明时的顺序存放

## 定义结构体：

    type struct_variable_type struct {
        member definition;
        member definition;
        ...
        member definition;
    }

    // 匿名类型结构（直接创建结构变量）
    var myemployee struct {  
        firstName, lastName string
        age, salary         int
    }
    // 匿名字段：字段名默认为对应数据类型名称（数据类型不能重复）
    type Person struct {
        string
        int
    }
    p := Person{"Naveen", 50}
    p.int =60

> 一旦定义了结构体类型，它就能用于变量的声明:

    type Employee struct { 
        ID int 
        Name string 
        Address string 
        DoB time.Time 
        Position string 
        Salary int 
        ManagerID int 
    }
    var dilbert Employee

+ 结构体类型的零值是每个成员都是零值
+ 如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息

## 带标签的结构体

    type User struct {
        UserName string "用户名称"
        UserId   int    `json:"user_id" bson:"b_user_id"`
    }

+ 结构体中的字段除了名字和类型外，还可以有一个可选的标签（tag）
+ 标签是一个附属于字段的字符串，用于描述字段信息
+ 标签还可以按\`key1:“value1” key2:“value2”\`键值对进行修饰，来提供编码、解码、ORM等转化辅助，比如JSON、BSON 等格式序列化
+ 使用反射，获取结构体标签的每一个键值对

## 结构体变量的访问与赋值：

    // 通过点操作符访问并赋值
    dilbert.Salary -= 5000 // demoted, for writing too few lines of code
    // 通过指针访问与赋值
    position := &dilbert.Position 
    *position = "Senior " + *position
    // 点操作符和指向结构体的指针一起工作
    var employeeOfTheMonth *Employee = &dilbert 
    employeeOfTheMonth.Position += " (proactive team player)"
    // 等价于
    (*employeeOfTheMonth).Position += " (proactive team player)"
   
+ 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。
+ 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身
+ 但是S类型的结构体可以包含 *S 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等

> 结构体字面值可以指定每个成员的值

    type Point struct{ X, Y int }
    // 方法一
    p := Point{1, 2}
    // 方法二
    p := Point{X:1, Y:2}
    // 创建并初始化一个结构体变量，并返回结构体的地址
    pp := &Point{1, 2}
    // 等价于
    pp := new(Point) 
    *pp = Point{1, 2}

+ 方法一要求以结构体成员定义的顺序为每个结构体成员指定一个字面值,结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{red, green, blue, alpha}
+ 方法二结构体字面值写法中，如果成员被忽略的话将默认用零值，因为，提供了成员的名字，所有成员出现的顺序并不重要

> 结构体的比较

+ 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。
+ 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型

## 结构体作为函数的参数和返回值：

    func Scale(p Point, factor int) Point { 
        return Point{p.X * factor, p.Y * factor} 
    }
    fmt.Println(Scale(Point{1, 2}, 5)) // "{5 10}"

    // 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回
    func Bonus(e *Employee, percent int) int { 
        return e.Salary * percent / 100 
    }

    // 如果要在函数内部修改结构体成员的话，用指针传入是必须的
    func AwardAnnualRaise(e *Employee) { 
        e.Salary = e.Salary * 105 / 100 
    }

## 利用map + 空结构体 模拟set数据结构

    seen := make(map[string]struct{}) // set of strings 
    // ... 
    if _, ok := seen[s]; !ok { 
        seen[s] = struct{}{} 
        // ...first time seeing s... 
    }

## 结构体嵌入和匿名成员

    // 定义
    type Point struct { 
        X, Y int 
    }
    type Circle struct { 
        Point 
        Radius int 
    }
    type Wheel struct { 
        Circle 
        Spokes int 
    }
    // 使用
    var w Wheel 
    w.X = 8 // equivalent to w.Circle.Point.X = 8
    w.Y = 8 // equivalent to w.Circle.Point.Y = 8 
    w.Radius = 5 // equivalent to w.Circle.Radius = 5 
    w.Spokes = 20

    // 结构体字面值并没有简短表示匿名成员的语法
    w = Wheel{8, 8, 5, 20} // compile error: unknown fields 
    w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
    // 必须遵循形状类型声明时的结构
    w = Wheel{Circle{Point{8, 8}, 5}, 20}
    // 等价于
    w = Wheel{ 
        Circle: Circle{ 
            Point: Point{X: 8, Y: 8}, 
            Radius: 5, 
        },
        Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) 
    }

+ 匿名成员：只声明一个成员对应的数据类型而不指名成员的名字
+ 匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针
+ 上面的代码中，Circle和Wheel各自都有一个匿名成员。
+ 我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。
+ 匿名成员并不是真的无法访问了。匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分
+ 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。
+ 同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束
+ 匿名成员并不要求是结构体类型；任何命名的类型都可以作为结构体的匿名成员(为了获得此成员的方法，用来组合成有复杂行为的对象)

> 子结构字段提升（没有同名父结构字段）

    type Address struct {  
        city, state string
    }
    type Person struct {  
        name string
        age  int
        Address  //子结构匿名
    }
    func main() {  
        var p Person
        p.name = "Naveen"
        p.age = 50
        p.Address = Address{
            city:  "Chicago",
            state: "Illinois",
        }
        fmt.Println("Name:", p.name)
        fmt.Println("Age:", p.age)
        fmt.Println(“City:”, p.city) //city 提升
        fmt.Println(“State:”, p.state) //state 提升
    }

+ 匿名子结构的字段可以像父结构字段一样被访问