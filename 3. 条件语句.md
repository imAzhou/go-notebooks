<!--
 * @Author: Azhou
 * @Date: 2021-09-27 20:41:14
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-01 20:43:21
-->
# Go语言条件语句
> Go 语言提供了以下几种条件判断语句：
1. if语句
2. if...else语句
3. switch语句
4. select语句


## if语句

    if(布尔表达式){
    
    }

## if...else语句

    if(布尔表达式){
   
    }else{
    
    }

## switch语句
> switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也**不需要再加**break

    switch var1 {
        case val1:
            ...
        case val2:
            ...
        case val3, val4, val5:
            ...
        default:
            ...
    }
+ 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值
+ 类型不被局限于常量或整数，但必须是相同的类型,或者最终结果为相同类型的表达式
+ 可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val3, val4, val5

> Type Switch: 用于判断某个 interface 变量中实际存储的变量类型

    package main

    import "fmt"

    func main() {
        var x interface{}
            
        switch i := x.(type) {
            case nil:	  
                fmt.Printf(" x 的类型 :%T",i)                
            case int:	  
                fmt.Printf("x 是 int 型")                       
            case float64:
                fmt.Printf("x 是 float64 型")           
            case func(int) float64:
                fmt.Printf("x 是 func(int) 型")                      
            case bool, string:
                fmt.Printf("x 是 bool 或 string 型" )       
            default:
                fmt.Printf("未知型")     
        }   
    }

> 没有条件的switch

    t := time.Now()
    switch {
    case t.Hour() < 12:
        fmt.Println("Good morning!")
    case t.Hour() < 17:
        fmt.Println("Good afternoon.")
    default:
        fmt.Println("Good evening.")
    }


## select语句
> select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。

> select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。

> 代码示例：

    package main

    import "fmt"

    func main() {
        var c1, c2, c3 chan int
        var i1, i2 int
        select {
            case i1 = <-c1:
                fmt.Printf("received ", i1, " from c1\n")
            case c2 <- i2:
                fmt.Printf("sent ", i2, " to c2\n")
            case i3, ok := (<-c3):  // same as: i3, ok := <-c3
                if ok {
                    fmt.Printf("received ", i3, " from c3\n")
                } else {
                    fmt.Printf("c3 is closed\n")
                }
            default:
                fmt.Printf("no communication\n")
        }    
    }

+ 每个case都必须是一个通信
+ 所有channel表达式都会被求值
+ 所有被发送的表达式都会被求值
+ 如果任意某个通信可以进行，它就执行；其他被忽略。
+ 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
+ 否则：
  + 如果有default子句，则执行该语句。
  + 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。