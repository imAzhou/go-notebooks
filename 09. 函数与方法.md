<!--
 * @Author: Azhou
 * @Date: 2021-09-29 19:26:23
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-04 22:35:53
-->
# Go语言函数与方法
## 编译型语言代码运行机制

+ 编译型语言把文本代码编译成二进制程序，运行时的进程是包括四块部分的内存结构
  + 代码区：索引了函数块执行代码
  + 全局数据区：全局数据、常量、静态全局量和局部量
  + 堆区：动态内存，供程序随机申请
  + 栈区：函数数据区
+ 通过栈机制实现函数的调用

## 函数
### 函数声明

    func function_name( [parameter list] ) [return_types]{
        // 函数体
    }
    // 例如：
    func f(i, j, k int, s, t string) { 
        /* ... */ 
    }
    func sub(x, y int) (z int) { 
        z = x - y; 
        return
    }

+ func：函数由 func 开始声明
+ function_name：函数名称，函数名和参数列表一起构成了函数签名。
+ parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
+ return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
+ 函数体：函数定义的代码集合。
+ 返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0
+ 不支持函数重载
+ 不支持默认值参数

### 函数的不定参数
+ 不定参数，形参数目可变、不确定
+ 不定参数声明语法格式： param … type
+ 不定参数类型必须相同
+ 不定参数必须是函数的最后一个参数
+ 不定参数的形参在函数内是切片
+ 切片传递给不定参数时，要用…运算符取出各元素

### 没有函数体的函数声明

    package math 
    func Sin(x float64) float //implemented in assembly language
    
+ 这表示该函数不是以Go实现的。
+ 这样的声明定义了函数标识符

### 函数类型

+ 函数类型又叫函数签名，显示函数类型：fmt.Printf("%T\n", funcname)
+ 函数类型包括`形参列表`和`返回值列表`
  + 形参列表：形参的次序、个数和类型（形参名无关）
  + 返回值列表：返回值的次序、个数和类型（返回值名无关）
+ 可以使用type定义函数类型
+ 函数类型是引用类型，未初始化的零值为nil
+ 标准定义的函数名为常量，不可修改指向
+ 函数是第一公民，函数变量可赋值、传参等

### defer

    defer println("last")
    println("main body")
    println("first")
    //main body
    //first
    //last

+ Go 函数支持defer进行延迟调用
+ defer 类似OO语言异常处理中的finally子句，常用来保证系统资源的回收和释放

> defer 实参

    a := 5
    defer fmt.Println(“defer 注册函数时的a值", a)
    a = 10
    fmt.Println(“普通函数的a值", a)
    //普通函数的a值 10
    //defer 注册函数时的a值 5

+ 在注册defer函数 时，会把当时的实参值传递给形参，后续实参的变化不影响函数结果

> 多个defer

    name := "Naveen"
    fmt.Printf("Original String: %s\n", string(name))
    fmt.Printf("Reversed String: ")
    for _, v := range []rune(name) {
        defer fmt.Printf("%c", v)
    }
    //Original String: Naveen
    //Reversed String: neevaN

+ 使用多个defer时，这些defer 调用 以先进后出（FILO）顺序在函数返回前被执行

## 方法

+ 方法是对具体类型行为的封装，本质上是绑定到该类型的函数
+ 非命名类型不能定义方法
+ OO语言的方法通常有个隐藏的this或self指针来指向对象
+ GO 把这个隐藏指针暴露出来，称为接收者（receiver）
+ 接收者可自定义名称，语法格式：
  + 值类型 func (t Type) funcName(paramList)(resultList)
  + 指针   func (t *Type) funcName(paramList)(resultList)
+ GO 的函数不能重载，导致不同类型不能用同名函数，而不同类型的方法可以同名
+ GO 不支持class ,使用结构代替类，结构字段用来封装对象属性，方法用来封装对象的行为


> 方法声明

    func (variable_name variable_data_type) function_name() [return_type]{
        /* 函数体*/
    }

    // eg:

    /* 定义结构体 */
    type Circle struct {
        radius float64
    }
    //该 method 属于 Circle 类型对象中的方法
    func (c Circle) getArea() float64 {
        //c.radius 即为 Circle 类型对象中的属性
        return 3.14 * c.radius * c.radius
    }

    // 方法调用：
    func main() {
        var c1 Circle
        c1.radius = 10.00
        fmt.Println("圆的面积 = ", c1.getArea())
    }

> 方法的相关特征

+ 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。
+ C++ 等语言中，实现类的方法做法都是编译器隐式的给函数加一个 this 指针，而在 Go 里，这个 this 指针需要明确的申明出来，也就是定义的接受者，其实和其它 OO 语言并没有很大的区别。
+ 关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针
+ 方法并非结构体专有，所有自定义类型都可以定义方法
+ 匿名子结构的方法可以像父结构方法一样被使用（没有同名父结构方法）

> 方法值

+ 方法本质上还是函数，所以方法可以赋值给函数变量
+ 方法值是对象变量初始化后的方法
+ 方法值其实是带有闭包的函数变量，接收者被隐式地保存在闭包里
+ 方法值赋给函数变量后，函数变量可直接调用
+ 方法也可以直接通过类型来调用，把接收者作为第一个参数
