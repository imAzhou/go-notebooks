<!--
 * @Author: Azhou
 * @Date: 2021-09-28 19:31:22
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-04 08:35:29
-->
# Go语言Map(映射)

+ 映射用于存储一系列无序的键值对
+ 在GO中映射跟数组一样直接使用，无须引用外部库
+ 映射也是引用类型，不支持==运算（除了nil)
+ 映射的键（key） 只支持值类型（可以使用==运算符作比较）
+ 映射的值(value)不限制，但所有元素的值类型一致 
+ GO 映射的底层实现是哈希数组链表，不是 C++的红黑树

## 声明Map

    // 方法一: 通用方法
    var map_variable map[key_data_type]value_data_type
    // 方法二: 使用make
    map_variable := make(map[key_data_type]value_data_type)
    // 方法三: 使用字面值语法创建
    ages := map[string]int{ 
        "alice": 31, 
        "charlie": 34, 
    }
    // 空map
    var ages map[string]int 
    fmt.Println(ages == nil) // "true" 
    fmt.Println(len(ages) == 0) // "true"

+ 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对, 也就是没有引用任何哈希表
+ 创建空的map的表达式是 map[string]int{}
+ map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。
+ 但是向一个nil值的map存入元素将导致一个panic异常

> 和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，必须通过遍历map进行判断

> Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set 的功能

## map遍历

    for name, age := range ages {
        ages[name]++
        fmt.Printf("%s\t%d\n", name, age) 
    }

    _ = &ages["bob"] // compile error: cannot take address of map element
    // 判断某一key是不是map的键
    age, ok := ages["bob"] 
    if !ok { /* "bob" is not a key in this map; age == 0. */ }

+ 如果一个查找失败将返回value类型对应的零值
+ map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作
+ 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效
+ Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序
  + 在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同
  + 这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现
  + 如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序

## Map排序【以 map[string]int 为例】
按key值的字符顺序排序，代码如下：

    import "sort" 
    
    names := make([]string, 0, len(ages))
    for name := range ages {
        names = append(names, name) 
    }
    sort.Strings(names) 
    for _, name := range names { 
        fmt.Printf("%s\t%d\n", name, ages[name]) 
    }

## 删除Map元素

    delete(ages, "alice") // remove element ages["alice"]

+ 即使这一元素不在map中也没有关系，删除操作仍旧是安全的