<!--
 * @Author: Azhou
 * @Date: 2021-11-05 19:31:27
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-05 23:14:40
-->
# Go语言的并发
+ 并行(parallelism)是在任一粒度的时间内都同时执行，比如多机并行
+ 并发(concurrent)是在规定的时间内多个任务都在执行，实际底层是分时操作
+ 并行强调瞬时性、并发强调过程性
+ 并行关键在于执行、并发关键在于结构
+ 单机运行时，并行通过使用多处理器以提高速度，并发程序可以是并行的，也可以不是
+ 应用程序具备好的并发结构，操作系统才能更好地利用硬件并行执行

## 进程( process )、线程( thread )和协程( coroutine )
+ 进程是程序在内存中运行时，操作系统对其进行资源分配和调度的独立单位
+ 线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
+ 每个进程至少包括一个线程
+ 每个进程的初始线程被称为主线程，主线程终止，进程终止
+ 协程是轻量级的线程，一个线程可以拥有多个协程
+ 进程和线程是`操作系统`级的，协程是`编译器`级的。协程不被操作系统内核管理，而完全由程序控制，因此没有线程切换的开销。
+ 和多线程比，数量越多，协程的性能优势就越明显。协程的最大优势在于其轻量级，可以轻松创建上万个而不会导致系统资源衰竭

### coroutine特性
+ coroutine特性是协作式任务处理，将函数或者语句在独立的环境中运行
+ C#、Lua、Python语言都支持coroutine特性
+ coroutine通常是`分时顺序`执行
+ coroutine通常是单线程，需要其主动交出控制权，程序才能获得控制权并将控制权交给其他coroutine，通常使用yield和resume等语法进行同步和协作

### Goroutine
+ 多数语言在语法层不支持协程，而是通过库方式，效率不高，容易阻塞
+ Go 在语言级别支持协程
  + 命名为goroutine，关键字go 
  + 由Go语言运行时统一调度，合理分配给各个CPU
+ goroutine 特性
  + 各goroutine非阻塞，不会等待
  + goroutine 可以并行执行
  + goroutine执行的函数返回值被忽略
  + 运行时不保证各goroutine的执行顺序
  + goroutine之间被平等地调度和执行
  + main函数会单独创建和分配一个goroutine

### 并发的运行性能
+ Go1.5版本之前，默认使用单核执行。Go1.5版本开始，可以通过执行<code>runtime.GOMAXPROCS</code>（逻辑CPU数量），让代码并发执行，最大效率地利用CPU。
+ GOMAXPROCS(n int) int 用来设置或查询可以并发执行的 goroutine 数目（默认对应cpu核数）
  + n<1 查询可以并发执行的 goroutine 数目
  + n=1 单核执行
  + n>1 多核并发执行
+ Goexit（）结束当前 goroutine 的运行
+ Gosched （）将当前goroutine 放到队列中等待下次调度
+ NumCPU返回 CPU 核数量

### 协程间的通信
> 协程间的通信常见两种方式

+ 共享数据。很多语言采用共享内存来实现程序数据同步，确保程序以合乎逻辑的方式执行。在程序执行过程中，进程或线程可能对共享数据加锁，以禁止其他进程或线程修改它。总体编程复杂性高。
+ 消息机制。每个并发单元是独立个体，多个并发单元的数据不共享，通过消息通信来同步数据。

**GO语言以并发为核心优势，采用消息机制**

## channel 通道
+ 通道是一种特殊的类型，同时只能有一个 goroutine 访问通道进行发送和获取数据。
+ 通道是一个队列，遵循先入先出（FIFO）的规则
+ 通道默认是阻塞的，使goroutine有效通信，不需要使用其他语言的显式锁或条件变量
+ 通道是引用类型，需要使用chan关键字和内置函数make 进行创建
+ 通道写入和读取使用  <code><-</code>  运算符 
  + 写入 ：通道<code><-</code>变量  
  + 读取： 变量<code><-</code>通道

### 缓冲通道

    func receiver(c chan string) {
        for msg := range c {
            fmt.Println(msg)
        }
    }
    func main() {
        messages := make(chan string, 2)
        messages <- "hello"
        messages <- "world"
        go receiver(messages)   
        time.Sleep(time.Second * 1)
    }//hello world

    ch := make(chan string, 3)
    ch <- "naveen"
    ch <- "paul"
    fmt.Println("capacity is", cap(ch))     // capacity is 3
    fmt.Println("length is", len(ch))       // length is 2
    fmt.Println("read value", <-ch)         // read value naveen
    fmt.Println("new length is", len(ch))   // new length is 1

+ 通道包括无缓冲通道和有缓冲通道
  + 无缓冲通道   make(chan  datatype)
  + 有缓冲通道   make(chan  datatype，capacity)
+ 无缓冲通道只能存储一条消息，有缓冲通道可以根据make函数的capacity参数存储n条消息，按FIFO读出
+ 用内置函数返回缓冲通道状态
  + len()获取通道当前缓存数
  + cap()获取通道缓存容量

### 死锁
> 缓冲与阻塞

+ 无缓冲通道，写入等待读取，读取等待写入，在双方准备好之前是阻塞的
+ 有缓冲通道，通道已满时的写入会等待，通道已空的读取会等待

> 死锁场景：

+ 通道无数据或未写入时，未启动写入协程就进行读取
+ 通道已满时，未启动读取协程就继续写入

### 单向通道
+ 通道默认为双向的，单向通道只能用于发送或接收数据
+ 所谓单向通道只是对通道作为函数参数的一种使用限制，跟C语言使用const修饰函数参数为只读类似
+ 通常先创建双向通道，在函数形参中利用<-运算符修饰通道，使之变为只读或只写通道
  + <code> func pump(ch chan<- int)  //只写 </code>
  + <code> func pull(ch <-chan int) //只读 </code>

### 关闭通道

    func producer(chnl chan int) {  
        for i := 0; i < 10; i++ {
            chnl <- i
        }
        close(chnl)
    }
    func main() {  
        ch := make(chan int)
        go producer(ch)
        // 一般写法
        for {
            v, ok := <-ch
            if ok == false {
                break
            }
            fmt.Println("Received ", v, ok)
        }
        // 使用range 
        for v := range ch {
            fmt.Println("Received ",v)
        }
    }

+ 关闭通道使用内置函数close(),实际上是关闭写入，即发送者告诉接收者不会再有数据发往通道
+ 接收者能够在通道接收数据的同时，获取通道是否已关闭的参数
+ for range 语句能自动判断通道是否已关闭

## 定时器
> 协程间的通信需设置超时等辅助机制
 
### 一次性定时器Timer：定时器只计时一次，结束便停止
+ 主要方法:
  + func NewTimer(d Duration) *Timer 指定一个时间创建一个Timer，Timer一经创建便开始计时，不需要额外的启动命令
  + func (t *Timer) Stop() bool  停止计时器，返回值true：定时器超时前停止， false: 定时器超时后停止
  + func (t *Timer) Reset(d Duration) bool  停掉定时器，再启动，返回值同上
  + func After(d Duration) <-chan Time  创建匿名不需控制的计时器
  + func AfterFunc(d Duration, f func()) *Timer  延迟方法调用

### 周期性定时器Ticker：定时器周期性进行计时，除非主动停止，否则将永久运行
+ 主要方法:
  + func NewTicker(d Duration) *Ticker 指定一个时间创建一个Ticker ， Ticker一经创建便开始计时，不需要额外的启动命令
  + func (t *Ticker) Stop() 停止计时，但管道不会被关闭

## WaitGroup、select、context、mutex、RWMutex、Cond

### WaitGroup
+ WaitGroup提供多个协程同步的机制，用来等待多个协程完成
+ 信号量， Unix中保护共享资源的机制，用于防止多个线程同时访问某个资源
  + 信号量>0，表示资源可用，获取信号量时系统自动将信号量减1
  + 信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒
+ WaitGroup 的方法
  + Add(delta int)  添加等待信号量
  + Done() 释放等待信号，每次减少1

### select
+ 多路复用是在一个信道上传输多路信号或数据流，比如网线
+ select 借用网络多路复用的概念，用于监听多个通道，同时响应多个通道
  + 多个通道都没有可写或可读的状态，select 会阻塞
  + 有一个通道是可写或可读的， select 会执行该通道语句
  + 有多个通道是可写或可读的， select 会随机选择其中一个执行

### context

    // Context接口
    type Context interface {
        //返回超时时间和是否已设置超时时间
        Deadline() (deadline time.Time, ok bool)
        //返回信道，当Context被撤销或过期时，该信道是关闭的
        Done() <-chan struct{}
        //Done信道关闭后，Err方法表明Context被撤销的原因
        Err() error
        //协程间的数据共享
        Value(key interface{}) interface{}
    }
    //将父节点复制到子节点，返回一个可以主动撤销Context的函数
    func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

    //过期时间由deadline和parent的过期时间共同决定，parent过期时间优先
    func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

    //与WithDeadline类似，只不过传入的是从现在开始Context剩余的生命时长
    func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

    //将父节点复制到子节点，子节点可扩展新的key存储的值
    func WithValue(parent Context, key interface{}, val interface{}) Context


+ WaitGroup用来控制多个平级goroutine同时完成
+ goroutine本身是平等的，但逻辑上可能有父子关系，context 表示程序上下文，是程序的运行状态，用来控制具有逻辑父子关系的多个goroutine
+ 用context的树结构来给平等的goroutine 设置父子逻辑
+ context树的根节点通常是一个空的context ,由第一个goroutine用Background() 函数创建，该context不能被取消、没有值、也没有过期时间

### mutex
+ 多个线程同时竞争使用某个变量可能会导致结果失控
+ mutex，互斥锁，用来保证某个变量在任一时刻，只能有一个线程访问
+ mutex 用Lock()和Unlock()来创建资源的临界区，这一区间内的代码是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码
+ mutex 也可以用通道来代替，二者无优劣之分，通常不涉及线程交互数据的用mutex，其他用通道

### RWMutex
> RWMutex在Mutex的基础之上增加了读、写的信号量，并使用了类似引用计数的读锁数量

+ 可以同时申请多个读锁
+ 有读锁时申请写锁将阻塞
+ 只要有写锁，后续申请读锁和写锁都将阻塞
+ 主要方法：
  + func (rw *RWMutex) Lock() //申请写锁
  + func (rw *RWMutex) Unlock() //释放写锁
  + func (rw *RWMutex) RLock() //申请读锁
  + func (rw *RWMutex) RUnlock()//释放读锁

### Cond（ condition 条件变量）

+ 互斥锁保证在同一时刻仅有一个线程访问某一个共享数据
+ 条件变量在共享数据的状态发生变化时，通知其他因此而被阻塞的线程
+ 条件变量需要用互斥锁来创建
> 主要方法：

    // 实例化一个带有Locker的Cond变量
    func NewCond(l Locker) *Cond

    //Unlock()->阻塞等待通知(等待Signal()或Broadcast()的通知)->收到通知->Lock()
    func (c *Cond) Wait()
     
    //激活执行Wait()的通知队列的第一个协程
    func (c *Cond) Signal()

    //激活执行Wait()的通知队列所有协程 
    func (c *Cond) Broadcast()

    //使用内置的互斥锁
    cond.L.Lock()和cond.L.Unlock()
