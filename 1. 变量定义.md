<!--
 * @Author: Azhou
 * @Date: 2021-09-27 17:32:47
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-01 20:41:59
-->
# Go语言变量

## token(标记)
> Go语言token包括：
+ 关键字
  + 包导入声明: import、package
  + 实体声明与定义: chan const func interface map struct type var
  + 流程控制: break case continue default defer else fallthrough for go goto if select switch range return
+ 标识符
  + 预声明标识符(预定义常量、内置函数等)(40个)
    + 内置数据类型(20个): bool、int、string等
    + 内置函数明(15个): make、new、panic等
    + 内置常量(4个): true、false、iota、nil
    + 空白标识符: _
  + 用户自定义标识符(变量名、包名、函数名等)(用于标识变量名、函数等)
    + 标识符不能是关键字
    + 标识符不能以数字开头
    + 标识符不能包含@,$,%等符号
    + 标识符大小写敏感
    + 部分标识符的首字母大小写有特殊含义（外部可用性）
+ 分隔符
  + 运算符(算术运算符、逻辑运算符等)
  + 纯分隔符(空格、制表符、回车、换行等)
+ 字面量(整型、浮点型、字符型、字符串型等)

## 变量声明
第一种，指定变量类型，声明后若不赋值，使用默认值。

    var v_name v_type
    v_name = value
第二种，根据值自行判定变量类型。

    var v_name = value
第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。

    v_name := value

## 多变量声明

    //类型相同多个变量, 非全局变量
    var vname1, vname2, vname3 type
    vname1, vname2, vname3 = v1, v2, v3

    var vname1, vname2, vname3 = v1, v2, v3 //和python很像,不需要显示声明类型，自动推断

    vname1, vname2, vname3 := v1, v2, v3 //出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误；这种不带声明格式的只能在函数体中出现


    //类型不同多个变量, 全局变量, 局部变量不能使用这种方式
    var (  //这种只能出现在全局变量中，函数体内不支持
        vname1 v_type1
        vname2 v_type2
    )

## 常量
> 1 . 常量是一个简单值的标识符，在程序运行时，不会被修改的量
+ 常量不可改变，声明赋值必须同时进行
+ 常量存储在程序只读段区
+ 常量中的数据类型只可以是 _布尔型_ 、 _数字型（整数型、浮点型和复数）_ 和 _字符串_ 型  

常量的定义格式:

    const identifier [type] = value
    const a string = "abc"
    const b = "abc"
    const c_name1, c_name2 = value1, value2

常量还可以用作枚举：

    const (
        Unknown = 0
        Female = 1
        Male = 2
    )
常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是**内置函数**，否则编译不过：

    import "unsafe"
    const (
        a = "abc"
        b = len(a)
        c = unsafe.Sizeof(a)
    )

> 2 . iota
+ iota，特殊常量，可以认为是一个可以被编译器修改的常量。
+ 在每一个const关键字出现时，被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。

iota 可以被用作枚举值：

    const (
        a = iota    // a等于0
        b = iota    // b等于1
        c = iota    // c等于2
    )
可以简写为如下形式：

    const (
        a = iota
        b
        c
    )
iota 用法

    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
    // 0 1 2 ha ha 100 100 7 8

iota作为常量表达式的计算因子：

    package main

    import "fmt"
    const (
        i=1<<iota
        j=3<<iota
        k              // k = 3<<iota，此时iota = 2 => k = 3 * 2²
        l              // l = 3<<iota
    )

    func main() {
        fmt.Println("i=",i)
        fmt.Println("j=",j)
        fmt.Println("k=",k)
        fmt.Println("l=",l)
    }
    // i= 1,j= 6,k= 12,l= 24 

## 值类型和引用类型
> 1 . 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值
+ 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝
+ 你可以通过 _&i_ 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在 _栈_ 中
+ 内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同

> 2 . 更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存
+ 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置, 这个内存地址为称之为**指针**，这个指针实际上也被存在另外的某一个字中
+ 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址
+ 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制, 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响

## 注意事项
> 1 . 全局变量是允许声明但不使用, 而声明的局部变量必须被使用，否则会报编译错误

> 2 . 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a

> 3 . 空白标识符 _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值

> 4 . 并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)