<!--
 * @Author: Azhou
 * @Date: 2021-09-28 10:31:46
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-03 17:44:17
-->
# Go语言数组和切片

## 数组
### 声明数组
> Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：

    // var variable_name [SIZE] variable_type
    var balance [10] float32

+ 数组类型定义包括元素类型，数组长度（元素个数）
+ 元素类型相同的两个数组，数组长度不同则类型不同，相互不能复制
+ 数组变量声明后，其元素类型、数组长度均不可变  （定长性）

### 初始化数组

    var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
    // 等价
    var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}
    // 等价
    var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

+ 初始化数组中 {} 中的元素个数不能大于 [] 中的数字
+ 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小
+ 如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始 化值的个数来计算
+ 数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定
  
> 上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化:

    symbol := [...]string{0: "$", 1: "€", 2: "￡", 3: "￥"}
    r := [...]int{99: -1}

+ 在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略
+ 上面定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化

### 数组复制
> 数组变量之间进行复制时会拷贝整个数组（值拷贝）

    a := [...]string{"USA", "China", "India", "Germany"}
    b := a 
    b[0] = "Singapore"
    fmt.Println("a is ", a)
    fmt.Println("b is ", b) 
    
    //a is [USA China India Germany]  
    //b is [Singapore China India Germany]

### 数组元素访问与遍历
> 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：

    float32 salary = balance[9]

> for遍历

    a := [...]float64{67.7, 89.8, 21, 78}
    for i := 0; i < len(a); i++ { 
        fmt.Printf("%d the element of a is %.2f\n", i, a[i])
    }

> range遍历

    a := [...]float64{67.7, 89.8, 21, 78}
    // 第一个参数为序号，第二个为变量
    for i,v := range a { 
        fmt.Printf("%d the element of a is %.2f\n", i, v)
    }

### 二维数组
> 常用的多维数组声明方式：

    // var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
    var threedim [5][10][4] int

> 二维数组的初始化

    a = [3][4]int{  
        {0, 1, 2, 3},   
        {4, 5, 6, 7},   
        {8, 9, 10, 11}, //此处,不可忽略，否则报错
    }

> 二维数组的访问

    int val = a[2][3]

### 数组的比较

> 通过`==`比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候 数组才是相等的
> 不相等比较运算符`!=`遵循同样的规则

    a := [2]int{1, 2} 
    b := [...]int{1, 2} 
    c := [2]int{1, 3} 
    fmt.Println(a == b, a == c, b == c) // "true false false" 
    d := [3]int{1, 2} 
    fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int

## Slice切片
+ 切片是引用类型，不支持==运算（除了nil)
+ 在函数传参时，slice复制的是结构体拷贝，实现引用传递，即函数内修改slice的元素值会影响函数外slice的值(址传递)
+ 切片包括三个变量：
  + 底层数组指针
  + 切片当前长度
  + 切片容量（小于等于底层数组长度，超过时要变更底层数组）
+ 多维切片比多维数组灵活，每行元素个数不必相同

### slice声明：

    // 方法一：
    var identifier []type
    // 方法二：使用make([]T, length, capacity)
    var slice1 []type = make([]type, len)
    slice1 := make([]type, len)

+ 切片声明时，不能给定底层数组大小，否则变成数组声明
+ 声明后创建切片变量，但底层数组指针为nil，所以切片变量也为nil
+ 使用内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。
+ 在底层，make创建了一个匿名的数组变量，然后返回一个slice；切片底层数组会分配空间，并设置为对应类型零值

### 初始化slice：

    // 直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3
    // 不指定数组大小时，同时创建匿名数组和返回切片引用
    s :=[] int {1,2,3 }
    // 初始化切片s,是数组arr的引用
    s := arr[:]
    // 将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片
    s := arr[startIndex:endIndex]
    // 缺省endIndex时将表示一直到arr的最后一个元素
    s := arr[startIndex:]
    // 缺省startIndex时将表示从arr的第一个元素开始
    s := arr[:endIndex]
    // 通过切片s初始化切片s1
    s1 := s[startIndex:endIndex]

> 空(nil)slice
+ 一个切片在未初始化之前默认为 nil，长度为 0
+ 一个nil值的slice的行为和其它任意0长度的slice一样；例如reverse(nil)也是安全的
+ 除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice

> 内置的len和cap函数分 别返回slice的长度和容量

    // len=3 cap=5 numbers=[0 0 0]
    var numbers = make([]int,3,5)

> 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠

    // months是一个长度为13的数组，它的第一个元素是空字符串
    months := [...]string{1: "January", /* ... */, 12: "December"}
    Q2 := months[4:7]       // len = 3, cap = 9
    summer := months[6:9]   // len = 3, cap = 7

+ slice计算容量时，是从slice的第一个位置，到原数组的最后一个位置

> slice唯一合法的比较操作是和nil比较, 例如：

    if summer == nil { /* ... */ }

+ 一个零值的slice等于nil。
+ 一个nil值的slice并没有底层数组。
+ 一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的
+ 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断

### 切片的性能考虑
+ 切片引用底层数组，导致底层数组不能被垃圾回收
+ 在底层数组很大，切片很小时，存在明显内存浪费
+ 这时可以用内置函数make()新建目标切片，再用内置函数copy(目标切片,源切片) 实现切片与原较大底层数据的分离

## 数组和slice的联系
1. 一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象
2. 一个slice由三个部分构成：指针、长度和容量
   + 指针指向第一个slice元素对应的底层数组元素的地址
   + 长度对应slice中元素的数目（长度不能超过容量）
   + 容量一般是从slice的开始位置到底层数据的结尾位置
  
## 对数组和slice的操作
> 数组或slice的遍历

    arr := [...]int{6,2,4,9,8,3}
    // 遍历方法一
    for i:= 0;i<len(arr);i++{
        fmt.Print(arr[i],"\t")
    }
    // 遍历方法二
    for _, value := range arr{
        fmt.Println(value)
    }

> 向slice中追加元素
 
    // 尾部追加
    var a []int
    a = append(a, 1) // 追加1个元素
    a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式
    a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
    // 头部添加
    var a = []int{1,2,3}
    a = append([]int{0}, a...) // 在开头添加1个元素
    a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
    // 中间追加会直接覆盖原位置上的元素
    arr := [7]int{9, 8, 7, 6, 5, 4, 3}
    sli := arr[1:3]
    sli = append(sli, 20)
    fmt.Printf("%v\n", arr)     //[9 8 7 20 5 4 3]
    // append链式操作
    var a []int
    a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
    a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片

+ 在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多
+ 因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素
+ 每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。
+ 切片动态增加时，当超过底层数组容量大小时，会重新创建底层数组，并转移数据
+ 切片增长在元素小于1000时，成倍增长，超过1000，增长速率大概为1.25

> slice数组去重

    // 方法一
    func ArrayRemoveRepeated(arr []string) []string {
        sort.Strings(arr)
        i := 0
        var j int
        for {
            if i >= len(arr)-1 {
                break
            }
            for j = i + 1; j < len(arr) && arr[i] == arr[j]; j++ {
            }
            arr = append(arr[:i+1], arr[j:]...)
            i++
        }
        return arr
    }
    // 方法二
    func ArrayRemoveRepeatedTwo(arr []string) (newArr []string) {
        newArr = make([]string, 0)
        for i := 0; i < len(arr); i++ {
            repeat := false
            for j := i + 1; j < len(arr); j++ {
                if arr[i] == arr[j] {
                    repeat = true
                    break
                }
            }
            if !repeat {
                newArr = append(newArr, arr[i])
            }
        }
        return newArr
    }

> slice删除元素

    // 删除slice中间的某个元素并保存原有的元素顺序
    func remove(slice []int, i int) []int { 
        copy(slice[i:], slice[i+1:]) 
        return slice[:len(slice)-1] 
    }
    // 删除元素后不用保持原来顺序
    func remove(slice []int, i int) []int { 
        slice[i] = slice[len(slice)-1] 
        return slice[:len(slice)-1] 
    }

> slice reverse

    // 核心代码
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
    // 通用函数封装
    func reverseAny(s interface{}) {
        n := reflect.ValueOf(s).Len()
        swap := reflect.Swapper(s)
        for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
            swap(i, j)
        }
    }

## new和make的区别
> new的基本使用

    var v *int
	fmt.Println(*v)	// panic: runtime error: invalid memory address or nil pointer dereference
	fmt.Println(v) // <nil>
	v = new(int)
	fmt.Println(*v)	// 0
	fmt.Println(v)	// 0xc0000140c0

> 对普通类型进行new()处理

    type Name struct {
        P string
    }
    var av *[5]int
    var iv *int
    var sv *string
    var tv *Name

    av = new([5]int)
    fmt.Println(*av) //[0 0 0 0 0 0]
    iv = new(int)
    fmt.Println(*iv) // 0
    sv = new(string) 
    fmt.Println(*sv) //
    tv = new(Name)
    fmt.Println(*tv) //{}

> 对复合类型（数组，slice，map，channel等）进行new()处理

    // 对数组
    var a [5]int
    fmt.Printf("a: %p %#v \n", &a, a)       //a: 0xc04200a180 [5]int{0, 0, 0, 0, 0} 
    av := new([5]int)
    fmt.Printf("av: %p %#v \n", &av, av)    //av: 0xc000074018 &[5]int{0, 0, 0, 0, 0}
    (*av)[1] = 8
    fmt.Printf("av: %p %#v \n", &av, av)    //av: 0xc000074018 &[5]int{0, 8, 0, 0, 0}

    // 对切片
    var a *[]int
    fmt.Printf("a: %p %#v \n", &a, a)       //a: 0xc042004028 (*[]int)(nil)
    av := new([]int)
    fmt.Printf("av: %p %#v \n", &av, av)    //av: 0xc000074018 &[]int(nil)
    (*av)[0] = 8
    fmt.Printf("av: %p %#v \n", &av, av)    //panic: runtime error: index out of range

    // 对map
    var m map[string]string
    fmt.Printf("m: %p %#v \n", &m, m)       //m: 0xc042068018 map[string]string(nil) 
    mv := new(map[string]string)
    fmt.Printf("mv: %p %#v \n", &mv, mv)    //mv: 0xc000006028 &map[string]string(nil)
    (*mv)["a"] = "a"
    fmt.Printf("mv: %p %#v \n", &mv, mv)    //panic: assignment to entry in nil map

    // 对channel
    cv := new(chan string)
    fmt.Printf("cv: %p %#v \n", &cv, cv)    //cv: 0xc000074018 (*chan string)(0xc000074020) 
    cv <- "good"             //invalid operation: cv <- "good" (send to non-chan type *chan string)

> make的使用

    av := make([]int, 5)
    fmt.Printf("av: %p %#v \n", &av, av)    //av: 0xc000046400 []int{0, 0, 0, 0, 0}
    av[0] = 1
    fmt.Printf("av: %p %#v \n", &av, av)    //av: 0xc000046400 []int{1, 0, 0, 0, 0}
    mv := make(map[string]string)
    fmt.Printf("mv: %p %#v \n", &mv, mv)    //mv: 0xc000074020 map[string]string{}
    mv["m"] = "m"
    fmt.Printf("mv: %p %#v \n", &mv, mv)    //mv: 0xc000074020 map[string]string{"m":"m"}
    chv := make(chan string)
    fmt.Printf("chv: %p %#v \n", &chv, chv) //chv: 0xc000074028 (chan string)(0xc00003e060)
    go func(message string) {
        chv <- message // 存消息
    }("Ping!")
    fmt.Println(<-chv) // 取消息            //"Ping!"
    close(chv)

+ new和make是内建的两个函数，主要用来在堆上创建分配类型的内存
+ new一般用于普通类型的内存分配，内存清零，返回该类型指针，对复合类型使用时并不会分配一定长度的空间
+ make只能用于slice、map以及channel的初始化，返回引用
+ make既分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。