<!--
 * @Author: Azhou
 * @Date: 2021-11-01 09:41:45
 * @LastEditors: Azhou
 * @LastEditTime: 2021-11-05 17:29:12
-->
# Go语言接口
+ 接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。
+ 接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。
+ 接口是编程规约，一组方法签名的集合
+ 传统OO里，接口通常用来抽象定义对象的行为，具体过程在类里实现 ，类在定义时要声明实现了哪些接口
+ GO 接口采用非侵入式，即具体类型实现接口不用显式声明，只要其方法集是接口的超集，编译时会进行对应校验
+ GO 接口只有方法签名，没有数据字段，没有函数体代码
+ 类型的方法集是多个接口的超集，则实现多个接口

## 接口定义

> 接口定义

    package io

    type Writer interface {
        Write(p []byte) (n int, err error)
    }
    type Reader interface { 
        Read(p []byte) (n int, err error) 
    }
    type Closer interface { 
        Close() error 
    }

> 接口内嵌
   
    type ReadWriteCloser interface { 
        Reader 
        Writer 
        Closer 
    }
    // 使用接口内嵌
    type ReadWriter interface { 
        Reader 
        Writer 
    }
    // 不使用接口内嵌
    type ReadWriter interface { 
        Read(p []byte) (n int, err error) 
        Write(p []byte) (n int, err error) 
    }
    // 混合方式
    type ReadWriter interface { 
        Read(p []byte) (n int, err error) 
        Writer 
    }

## 接口实现

> 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口;接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口

    var w io.Writer 
    w = os.Stdout // OK: *os.File has Write method 
    w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method 
    w = time.Second // compile error: time.Duration lacks Write method 
    var rwc io.ReadWriteCloser 
    rwc = os.Stdout // OK: *os.File has Read, Write, Close methods 
    rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method

+ T类型的值不拥有所有 *T 指针的方法， 那这样它就可能只实现更少的接口。

> interface{}被称为空接口类型,空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型

    var any interface{} 
    any = true 
    any = 12.34 
    any = "hello" 
    any = map[string]int{"one": 1} 
    any = new(bytes.Buffer)

## 接口值
> 接口值，由两个部分组成，一个具体的类型和那个类型的值,它们被称为接口的动态类型和动态值

    // type: nil
    // value:nil
    var w io.Writer 
    // type:  *os.File
    // value:持有os.Stdout的拷贝(这是一个代表处理标准输出的os.File类型变量的指针)
    w = os.Stdout 
    // type: *bytes.Buffer
    // value:是一个指向新分配的缓冲区的指针
    w = new(bytes.Buffer) 
    // type: nil
    // value:nil
    w = nil

+ 从概念上讲，不论接口值多大，动态值总是可以容下它
+ 接口值可以使用＝＝和!＝来进行比较
+ 两个接口值相等仅当:
  + 它们都是nil值
  + 它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等
+ 因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数
+ 如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic
  + 在比较接口值或者包含了接口值的聚合类型时，必须要意识到潜在的panic
  + 同样的风险也存在于使用接口作为map的键或者switch的操作数

## 实现一些常用的接口

### flag.value接口
### sort.interface接口
### http.Handler接口
### error接口